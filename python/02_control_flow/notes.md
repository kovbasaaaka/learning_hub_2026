# Управление потоком - Конспект

## Конспект по теме: "Условный оператор `if-else`"

### Основные понятия:

Программы должны уметь выполнять различные действия в зависимости от введённых **данных**.

Для принятия решения **программа** проверяет, **истинно** или **ложно** определённое **условие**.
- Проверка **условий** и принятие решений по результатам этой **проверки** называется **ветвлением**(branching). **Программа** таким способом выбирает, по какой из возможных **ветвей** ей двигаться далее.

В **Python** проверка условия осуществляется при помощи **ключевого слова `if`**.
- Рассмотрим такую программу:

  ```python
  answer = input('Какой язык программирования мы изучаем?')
  if answer == 'Python':
    print('Верно! Мы ботаем Python =)')
    print('Python - отличный язык!')
  ```
  
**Программа** просит **пользователя** ввести текст и проверяет результат ввода. 

- Если введённый текст равен строке `Python`, то выводит **пользователю** текст:
  
  ```python
  Верно! Мы ботаем Python =)
  Python - отличный язык!
  ```

**Двоеточие (`:`)** в конце **строки с инструкцией `if`** сообщает интерпретатору **Python**, что дальше находится **блок команд**.

В **блок команд** входят **все строки с отступом под строкой с инструкцией `if`**, вплоть до следующей **строки без отступа**.

Если условие **истинно**, выполняется **весь расположенный ниже блок**.

В приведённом выше примере блок инструкций составляет третья и четвёртая строки программы.

**Блоком кода** называют объединённый друг с другом **строки**. Они **всегда** связаны с определённой частью программы(например с инструкцией  **`if`**)

Некоторым инструкциям в **Python** (например, инструкции **`if`**) именно **блок кода** сообщает, какие действия следует предпринять. После **`if`** блок кода информирует интерпретатор **Python**, как действовать, если условие **истинно**, и как — если оно **ложно**.

<img width="235" height="132" alt="image" src="https://github.com/user-attachments/assets/e05482ca-530c-43a4-9208-e5082c527d65" />

Предыдущая программа выводит текст в случае, если условие **истинно**. Но если условие **ложно**, то программа ничего не выводит.

- Для того, чтобы обеспечить возможность выполнять что-либо в случае, если условие оказалось **ложным**, необходимо использовать **ключевое слово `else`**:
  
  ```python
  answer = input('Какой язык программирования мы изучаем?')
  
  if answer == 'Python':
      print('Верно! Мы ботаем Python =)')
      print('Python - отличный язык!')
  else:
      print('Не совсем так!')
  ```

В новой программе обрабатываются сразу **два случая**: если условие **истинно**(пользователь ввёл **'Python'**) и если условие **ложно**(пользователь ввёл что угодно, кроме **'Python'**).

<img width="221" height="203" alt="image" src="https://github.com/user-attachments/assets/5552eee7-e075-4bf9-ba0d-f59ff40fbd42" />


#### Отступы


В некоторых языках программирования **отступы** - дело личного вкуса, и можно вообще обходиться без них. 

Однако в **Python** они - **неотъемлемая часть кода**. Именно **отступ** сообщает интерпретатору **Python**, где начинается и где заканчивается блок кода.

**Отступ** - небольшое смещение **строки кода** вправо. В начале такой **строки** находятся **пробелы**, и поэтому она на **несколько символов** отделена от **левого края**.


#### Операторы сравнения


Можно заметить, что в **проверке условия** использовалось **двойное равенство `==`** вместо ожидаемого **одиночного `=`**.

Не стоит путать **оператор присваивания `=`** с **условным оператором `==`**.

- **Оператор присваивания `=`** присваивает **переменным** значения:

  ```python
  num = 1992
  s = 'I love Python'
  ```

- Для проверки **двух элементов**  на равенство **Python** использует **удвоенный** знак равно **`==`**:

  ```python
  if answer == 'Python':
      ...
  
  if name == 'Gvido':
      ...
  
  if temperature == 40:
      ...
  ```

  
##### 6 основных операторов сравнения


- Оператор сравнения **больше `>`**:

  ```python
  if x > 7 # Если x больше 7
  ```
- Оператор сравнения **меньше `<`**:

  ```python
  if x < 7 # Если x меньше 7
  ```
- Оператор сравнения **больше либо равно `>=`**:
  
  ```python
  if x >= 7 # Если x больше либо равен 7
  ```
- Оператор сравнения **меньше либо равно `<=`**:

  ```python
  if x <= 7 # Если x меньше либо равен 7
  ```
- Оператор сравнения **равно `==`**:
  
  ```python
  if x == 7 # Если x равен 7
  ```
- Оператор сравнения **не равно `!=`**:

  ```python
  if x != 7 # Если x не равен 7
  ```

  
##### Цепочки сравнений


**Операторы сравнения** в **Python** можно объединят в **цепочки**(в отличие от большинства других языков программирования, где для этого нужно использовать **логические связки**).

Например, **`a == b == c`** или **`1 <= x <= 10`**.

- Следующий код проверяет, находится ли значение **переменной `age`** в диапазоне от 3 до 6:

  ```python
  age = int(input())
  if 3 <= age <= 6:
      print('Вы ребёнок')
  ```

  
##### Транзитивность


**Транзитивность** - это свойство отношения "переходить" или "передаваться" от одного **элемента** к друому: если **элемент a** связан с **b**, а **b** связан с **c**, то **a** также связан с **c**.

**Операция равенства - `==`** является **транзитивной**.

Это значит, что если **`a == b`** и **`b == c`**, то из этого следует, что **`a == c`**.

Именно поэтому код, проверяющий **равенство трёх переменных**, работает, как надо.

Другие примеры **транзитивных операций**:

- **Отношение порядка**: если a > b и b > c, то a > c;
- **Параллельность прямых**: если a || b и b || c, то a || c;
- **Делимость**: если a делится на b и b делится на c, то a делится на c.

Наглядный пример транзитивного отношения порядка: если друг слева старше вас(**a > b**), а вы старше друга справа(**b > c**) то друг слева точно старше друга справа(**a > c**).

**Операция неравенства `!=`** в отличие от **операции равенства `==`**, является **нетранзитивной**.

То есть из того, что **`a != b`** и **`b != c`** вовсе не следует, что **`a != c`**.

Действительно, если вас зовут не так, как одного из ваших друзей и не так, как ещё одного из ваших друзей, то нет никакой гарантии, что у этих друзей не окажутся одинаковые имена.


### Важные моменты:


По соглашению **PEP 8**, для **отступа блоков кода** используются **4 пробела**. 

Если в среде **VS Code** или **Wing IDE** нажать на клавишу **Enter** после **`if`**, она автоматически выставит **4 пробела**.

Путаница с операторами **`==`** и **`=`** является одной из **самых распространённых ошибок в программировании**.

Эти **символы** используются не только в **Python**, и каждый день **множество** программистов используют их **неправильно**.


###  Примеры кода:


1. Пример работы операторов сравнения:
   
  ```python
  num1 = int(input())
  num2 = int(input())
  
  if num1 < num2:
      print(num1, 'меньше чем', num2)
  if num1 > num2:
      print(num1, 'больше чем', num2)
  
  if num1 == num2:  # используем двойное равенство
      print(num1, 'равно', num2)
  if num1 != num2:
      print(num1, 'не равно', num2)
  ```

2. Пример кода, проверяющего равенство трёх переменных:
   
  ```python
  if a == b == c:
      print('числа равны')
  else:
      print('числа не равны')
  ```

3. Программа для подсчёта количества чётных чисел из 3 введённых:
   
  ```python
  num1, num2, num3 = int(input()), int(input()), int(input()) # Множественно считываем и присваиваем данные
  
  counter = 0  # переменная счётчик
  if num1 % 2 == 0:
      counter = counter + 1  # увеличиваем счётчик на 1
  if num2 % 2 == 0:
      counter = counter + 1  # увеличиваем счётчик на 1
  if num3 % 2 == 0:
      counter = counter + 1  # увеличиваем счётчик на 1
  
  print(counter)
  ```

4. Программа, которая определяет, состоит ли двузначное число введённое с клавиатуры из одинаковых цифр.
   
  ```python
  num = int(input())
  
  last_digit = num % 10    # последняя цифра числа
  first_digit = num // 10  # первая цифра числа
  
  if last_digit == first_digit:
      print('ДА')
  else:
      print('НЕТ')
  ```


## Конспект по теме: "Логические операторы, понятия truthy и falsy"


### Основные понятия:


В **Python** есть **три логических оператора**, которые позволяют создавать сложные условия:

- **`not`** - логическое отрицание;
- **`and`** - логическое умножение;
- **`or`** - логическое сложение.


#### Оператор `not`


**Оператор `not`** позволяет **инвертировать(т.е. заменить на противоположный)** результат **логического выражения**.

- Например следующий код:

  ```python
  age = int(input('Сколько вам лет?: '))
  if not (age < 12):
      print('Доступ разрешен.')
  else:
      print('Доступ запрещен.')
  ```
- Полностью эквивалентен коду:

  ```python
  age = int(input('Сколько вам лет?: '))
  if age >= 12:
      print('Доступ разрешен.')
  else:
      print('Доступ запрещен.')
  ```
В первом примере выражение **`age < 12`** было помещено в скобки для того, чтобы было чётко видно, что применяется **оператор `not`** к **значению выражения `age < 12`** а не только к **переменной `age`**.

**Операндом оператора `not`** может быть объект **любого типа**.

Если **операнд** отличен от значений **`True`** и **`False`**, он оценивается в соответствии с концепцией **`truthy`** и **`falsy`** объектов.

При этом результатом работы оператора **`not`** **всегда является** значение **`True`** или **`False`**.

- Приведённый ниже код:

  ```python
  print(not False)
  print(not None)
  print(not 0)
  print(not 0.0)
  print(not [])
  print(not '')
  print(not {})
  ```
  Выводит:
  
  ```python
  True
  True
  True
  True
  True
  True
  True
  ```

- Приведённый ниже код:
  
  ```python
  print(not True)
  print(not 123)
  print(not 69.96)
  print(not 'beegeek')
  print(not [4, 8, 15, 16, 23, 42])
  print(not {1, 2, 3})
  ```
  
  Выводит:
  
  ```python
  False
  False
  False
  False
  False
  False
  ```

  
##### Таблица истинности для оператора `not`


<img width="158" height="125" alt="image" src="https://github.com/user-attachments/assets/205a6877-a274-428a-b0a9-0dc5b3149a0e" />

Т.е. **оператор `not`** меняет значения на противоположные.


#### Оператор `and`


**Оператор `and`** означает, что в определённом **ветвлении** блок кода выполняется только при выполнении **обоих условий одновременно!**

- Например:
  
  ```python
  age = int(input('Сколько вам лет?: '))
  height = int(input('Каков ваш рост?: '))
  if age >= 18 and height >= 165:
      print('Доступ на водную горку разрешен.')
  else:
      print('Доступ на водную горку запрещен.')
  ```

Оператор **`and`** может объединят любое количество **условий**

Операндами оператора **`and`** могут быть **объекты любых типов данных**. По аналогии с оператором **`not`** можно предположить, что результатом работы оператора **`and`** также является значение **`True`** или **`False`**.

Однако на самом деле данный оператор возвращает **один из своих операндов**, а какой именно - зависит от самого **оператора**.

- Приведённый ниже код:

  ```python
  print(None and 10)
  print(5 and 0.0)
  print('aboba' and {})
  print([1, 2, 3] and [6, 9])
  
  print(1 and 'aboba' and None)
  print('habr' and 0 and {'one': 1})
  print(10 and [6, 9] and [])
  ```
  
  Выводит:
  
  ```python
  None
  0.0
  {}
  [6, 9]
  None
  0
  []
  ```

Из этого примера видно, что **оператор `and`** возвращает **первый `falsy` объект либо последний объект, если `falsy` объекты в логическом выражении не найдены**.


##### **Таблица истинности** для **оператора `and`**:


<img width="233" height="216" alt="image" src="https://github.com/user-attachments/assets/6c79a152-bd24-4f9a-8592-d5b9e0e963f6" />


Исходя из **таблицы истинности**, для выполнения кода, необходимо, чтобы одновременно выполнялись **абсолютно все условия**, связанные оператором **`and`**.


#### Оператор `or`


**Оператор `or`** также применяется для **объединения/связывания** условий.

В отличие от **`and`**, для выполнения **блока кода** достаточно выполнения **хотя бы одного из условий**.

Например:

  ```python
  town = input('В каком городе вы живёте?: ')
  if town == 'Екатеринбург' or town == 'Челябинск':
      print('Доступ открыт')
  else:
      print('Доступ закрыт')
  ```

Доступ будет разрешён если хотя-бы одно из условий выполнится.

Операндами **оператора `or`**, как в случае с **`not`** и **`and`**, могут быть объекты любых типов данных.

**Оператор `or`**, как и **оператор `and`** возвращает **один из своих операндов**. И какой именно, также зависит от самого **оператора**.

- Приведённый ниже код:

  ```python
  print(None or 0)
  print(0 or 5)
  print('aboba' or None)
  print([1, 2, 3] or [6, 9])
  
  print(1 or 'aboba' or None)
  print(0.0 or 'habr' or {'one': 1})
  print(0 or '' or [6, 9])
  print(0 or '' or [])
  print(0 or '' or [] or {})
  ```

  Выводит:

  ```python
  0
  5
  aboba
  [1, 2, 3]
  1
  habr
  [6, 9]
  []
  {}
  ```

Как видно из примера, **оператор `or`** оценивает каждый свой **операнд** как **`truthy`** или **`falsy`** объект, однако возвращает не значение **`True`** или **`False`**, а **сам объект** по определённому правилу - **первый `truthy` объект, либо последний объект, если `truthy` объекты в логическом выражении не найдены**.


##### **Таблица истинности для оператора `or`**:


<img width="229" height="212" alt="image" src="https://github.com/user-attachments/assets/c7b22df8-e3d8-4daf-8c62-8a6a02af00c6" />


Чтобы выражение **`or`** выполнялось, требуется, чтобы **хотя бы одно** условие **оператора `or`** выполнялось. 

При этом абсолютно не имеет значения, выполняется или нет второе или любое другое связанное условие.


#### Общий вывод по таблицам истинности логических операторов


Когда операндами **логических операторов** являются объекты **`True`** и **`False`**, работа **логических операторов** в **Python** также соответствует данным **таблицам истинности**.

- Приведённый ниже код:
  
  ```python
  print(not True)
  print(not False)
  print(False and True)
  print(True and True)
  print(False or True)
  print(False or False)
  ```
  Выводит:
  
  ```python
  False
  True
  False
  True
  True
  False
  ```
  
Однако **Python** не ограничивает нас только значениями **`True`** и **`False`** в качестве **операндов логических операторов**.

**Операндами операторов `not`, `and` и `or`** могут быть объекты **любых других типов данных**.


#### Понятия truthy и falsy объектов


Одной из важных особенностей языка **Python** является концепция **`truthy`** и **`falsy`** объектов.

Любой **объект** в **Python** может быть оценён как **`True`** или **`False`**. 

При этом **объекты**, которые оцениваются как **`True`**, называются **`truthy`** объектами.

А **объекты**, которые оцениваются как **`False`** - **`falsy`** объектами.


##### Что относится к встроенным `falsy` объектам


К встроенным **`falsy`** объектам относятся:

- значение **`False`**
- значение **`None`**
- нули числовых типов данных: **`0`**, **`0.0`**, **`0j`**, **`Decimal(0)`**, **`Fraction(0, 1)`**
- пустые последовательности и коллекции: **`''`**, **`()`**, **`[]`**, **`{}`**, **`set()`**, **`range(0)`**.

Другие **объекты встроенных типов данных** относятся к **`truthy` объектам**.

Экземпляры пользовательских классов по умолчанию также являются **`truthy`** объектами.


##### Встроенная функция `bool()`


Чтобы привести **объекты** к значению **`True`** или **`False`**, используется **встроенная функция `bool()`**.

- Приведённый ниже код:
  
  ```python
  # falsy объекты
  print(bool(False))
  print(bool(None))
  print(bool(0))
  print(bool(0.0))
  print(bool([]))
  print(bool(''))
  print(bool({}))
  
  #truthy объекты
  print(bool(True))
  print(bool(123))
  print(bool(69.96))
  print(bool('abobus'))
  print(bool([4, 8, 15, 16, 23, 42]))
  print(bool({1, 2, 3}))
  ```
  Выводит:
  
  ```python
  False
  False
  False
  False
  False
  False
  False
  True
  True
  True
  True
  True
  True
  ```


##### Работа `truthy` и `falsy` объектов с условным оператором


Концепция **`truthy`** и **`falsy`** объектов в **Python** позволяет работать с **условным  оператором** в более простой манере.

- Например, приведённый ниже код:
  
  ```python
  if len(data) > 0:
      ...
  
  if value == True:
      ...
  
  if value == False:
      ...  
  ```
  Можно переписать в виде:
  
  ```python
  if data:
      ...  
  
  if value:
      ...  
  
  if not value:
      ...
  ```

Т.е. можно не писать явных условий, пользуясь данной концепцией.


###### Примеры упрощённой записи условного оператора с различными объектами Python согласно концепции `truthy` и `falsy` объектов.


<img width="719" height="94" alt="image" src="https://github.com/user-attachments/assets/73f68668-8272-4ec6-b692-7c668543df0a" />


#### Приоритеты выполнения логических операторов


**Логические операторы**, подобно арифметическим операторам(`+`, `-`, `*`, `/`), имеют **приоритет выполнения**.

**Приоритет выполнения** следующий:

1. В **первую очередь** выполняется **логическое отрицание `not`**;
2. Во **вторую очередь** выполняется **логическое умножение `and`**;
3. И в **последнюю очередь** выполняется **логическое сложение `or`**.

- Согласно **приоритету логических операторов** приведённый ниже код:
  
  ```python
  a = 0
  b = 7
  c = 10
  print(not a and b or not c)        # 7
  ```

  Эквивалентен следующему:
  
  ```python
  a = 0
  b = 7
  c = 10
  print(((not a) and b) or (not c))  # 7
  ```

Но по отношению к другим **операторам Python**(за исключением **оператора присваивания `=`**) **логические операторы имеют самый низкий приоритет выполнения**.

Для **явного указания порядка** выполнения условных операторов **используют скобки**.

- Например, приведённый ниже код:
  
  ```python
  a = 5
  b = 7
  print(not a == b)  # True
  ```
  
  Эквивалентен следующему:
  
  ```python
  a = 5
  b = 7
  print(not (a == b))  # True
  ```

- Также стоит отметить, что запись вида:
  
  ```python
  a = 5
  b = 7
  print(a == not b)
  ```
  недопустима и приводит к возбуждению **исключения `SyntaxError`**.

Для наибольшей наглядности приведём ещё один пример.

- Приведённый ниже код:
  
  ```python
  print(not 1 == 2 or 3 == 3 and 5 == 6)  
  ```

  Выводит:
  
  ```python
  True
  ```

  Согласно **приоритету операторов** в **первую очередь** вычисляются выражения **`1 == 2`**, **`3 == 3`** и **`5 == 6`**, в результате чего **исходное выражение** принимает вид **`not False or True and False`**.
  
  Далее выполняется **оператор `not`**, возвращая значение **`True`**, после него - **оператор `and`**, возвращая значение **`False`**.
  
  **Выражение** принимает вид **`True or False`**. Последним выполняется **оператор `or`**, возвращая **общий результат выражения** - значение **`True`**.
  
#### Вложенный оператор

Внутри **условного оператора** можно использовать любые инструкции языка **Python**, в том числе и **условный оператор**.

При таком использовании получается **вложенное ветвление**: после одной развилки в ходе выполнения программы появляется другая. При этом **вложенные блоки имеют больший размер отступа**(+4 пробела для каждого следующего уровня)

- Вот как это должно выглядеть:
    
  ```python
  if условие1:
      блок кода
  else:
      if условие2:
          блок кода
      else:
          if условие3:
              блок кода            
        ...  
  ``` 

- Пример использования вложенного условного оператора:

  ```python
  grade = int(input('Введите вашу отметку по 100-балльной системе: '))
  
  if grade >= 90:
      print(5)
  else:
      if grade >= 80:
          print(4)
      else:
          if grade >= 70: 
              print(3)
          else:
              if grade >= 60:
                  print(2)
              else:
                  print(1)        
        ...  
    ``` 
  В этом примере уровень вложенности настолько глубок, что код становится трудным в понимании.

  Здесь имеет смысл избегать глубокого вложения. Для этого в **Python** есть **каскадный условный оператор**.

#### Каскадный условный оператор

Если требуется проверить **несколько** условий, в языке **Python** используется **каскадный условный оператор**.

- Синтаксис **каскадного условного оператора** имеет вид:
  
  ```python
  if условие1:
    блок кода
  elif условие2:
    блок кода
  ...
  else:
    блок кода
  ```

При исполнении такого **условного оператора** сначала проверяется **условие1**. Если оно истинно, то исполняется блок кода, который следует сразу после него вплоть до **выражения `elif`**. Остальная часть конструкции **игнорируется**. Однако, если **условие1** является ложным, то программа перескакивает непосредственно к следующему **выражению `elif`** и проверяет условие2. Если оно истинное, то исполняется блок кода, который следует сразу после него, вплоть до следующего **выражения `elif`**. И остальная часть условного оператора тогда **игнорируется**.

Этот процесс продолжается до тех пор, пока не будет найдено **условие**, которое является истинным, либо пока больше не останется **выражений `elif`**. Если ни одно условие не является истинным, то исполняется блок кода после **выражения `else`**.

- Пример каскадного условного оператора **`if-elif-else`**:
   
  ```python
  grade = int(input('Введите вашу отметку: '))
  
  if grade >= 90:
      print(5)
  elif grade >= 80:
      print(4)
  elif grade >= 70:
      print(3)
  elif grade >= 60:
      print(2)
  else:
      print(1)
  ```

Выравние и выделение отступом, которые применены в инструкции **`if-elif-else`**: выражения **`if`**, **`elif`** и **`else`** выравнены и исполняемые по условию блоки выделены одним отступом.


### Важные моменты:

#### Логические операторы ленивы

**Логические операторы** в **Python** являются **ленивыми**.

Это означает, что **возвращаемый операнд** вычисляется путём оценки **истинности** всех операндов **слева направо** до тех пор, пока это остаётся актуальным:

- Если **левый операнд** оператора **`or`** является **`truthy`** объектом, то общим результатом логического выражения является **`True`**, независимо от значения **правого операнда**.
- Если **левый операнд** оператора **`and`** является **`falsy`** объектом, то общим результатом логического выражения является **`False`**, независимо от значения **правого операнда**

Данный механизм называется **вычислением по короткой схеме(short-circuit evaluation)** и используется интерпретатором для оптимизации вычислений.

Наглядный пример:

- Приведённый ниже код :
  
  ```python
  def f():
      print('abo')
      return 3
    
  if True or f():
      print('bus')
  ```

  выводит:
  
  ```python
  bus
  ```

**Левым** операндом оператора **`or`** является **`truthy`** объект(значение **`True`**), значит, для вычисления **общего результата** логического выражения **нет необходимости вычислять правый операнд**, т.е. вызывать функцию **`f()`**. Поскольу вызова функции не происходит, в **выводе** отсутствует строка `abo`.

Общим результатом логического выражения является значение **`True`**, а значит, выполняются инструкции **блока кода** условного оператора, и в выводе видно строку `bus`.

- Напротив, приведённый ниже код:

  ```python
  def f():
      print('abo')
      return 3
    
  if True and f():
      print('bus')
  ```

  выводит:
  
  ```python
  abo
  bus
  ```
Т.к. **левым** операндом оператора **`and`**  является **`truthy`** объект, значит, для вычисления общего результата логического выражения **необходимо вычислить и правый операнд**, т.е. вызвать функцию `f()`. 

В результате вызова выполняются инструкции из **тела функции**, поэтому в выводе мы видим строку `abo`.

Функция возвращает число `3`, которое также является **`truthy`** объектом. Таким образом, общим результатом логического выражения является число `3`, а значит, выполняются инструкции **блока кода** условного оператора, и в выводе мы видим строку `bus`.

#### Укороченная схема вычисления `and` и `or`


**Оба оператора, `and` и `or`**, вычисляются по **укороченной схеме**.

Вот как это работает с **оператором `and`**:

- Если условие **слева** от **оператора `and`** является **ложным**, то условие **справа** от него **не проверяется**, так как **результат выражения будет гарантированно ложным** и проверка оставшегося условия — пустая трата процессорного времени.

- Например, в таком выражении:

  ```python
  5 > 100 and 10 > 0
  ```
  Вычисляется только выражение **`5 > 100`**. Оно **ложно**, а при **операторе `and`** оба выражения **должны быть правдивы**, чтобы **результат был `True`**.

  Но уже одно из выражений **не правдиво**, значит, результат и так будет **`False`**.

  Поэтому и **не требуется** вычислять **второе выражение**, т.к. оно **не повлияет на результат**.


**Аналогично работает оператор `or`**.


Если **условие слева** от **оператора `or`** - **истинное**, то **условие справа** от него **не проверяется**.

Действительно, результат будет **гарантированно истинным** и проверка оставшегося условия станет пустой тратой **процессорного времени**.

- Например, в таком выражении:
  
  ```python
  10 > 0 or 5 > 100
  ```
  вычисляется только **выражение `10 > 0`**. Оно **правдиво**, значит результат будет тоже **правдив**.

  Так как нам достаточно только **одного правдивого выражения** при **операторе `or`**.

#### Для вложенных и каскадных операторов

Инструкция **`if-elif-else`** не является обязательной, потому что её логика может быть запрограммирована вложенными инструкциями **`if-else`**. 

Однако длинная серия вложенных инструкций **`if-else`** имеет два характерных недостатка:

- программный код может стать сложным и трудным для восприятия;
- из-за необходимого выделения отступом продолжительная серия **вложенных инструкций `if-else`** может стать слишком длинной, чтобы целиком уместиться на экране монитора без горизонтальной прокрутки.

**Заключительный блок `else`** в операторе **`if-elif-else`** является **необязательным**.


### Примеры кода:


1. Одновременное использование **`and`** и **`or`**:

  ```python
  age = int(input('Сколько вам лет?: '))
  grade = int(input('В каком классе вы учитесь?: '))
  city = input('В каком городе вы живете?: ')
  if age >= 12 and grade >= 7 and (city == 'Москва' or city == 'Санкт-Петербург'):
      print('Доступ разрешен.')
  else:
      print('Доступ запрещен.')
  ```

