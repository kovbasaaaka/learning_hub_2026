# Управление потоком - Конспект

## Конспект по теме: "Условный оператор `if-else`"

### Основные понятия:

Программы должны уметь выполнять различные действия в зависимости от введённых **данных**.

Для принятия решения **программа** проверяет, **истинно** или **ложно** определённое **условие**.
- Проверка **условий** и принятие решений по результатам этой **проверки** называется **ветвлением**(branching). **Программа** таким способом выбирает, по какой из возможных **ветвей** ей двигаться далее.

В **Python** проверка условия осуществляется при помощи **ключевого слова `if`**.
- Рассмотрим такую программу:

  ```python
  answer = input('Какой язык программирования мы изучаем?')
  if answer == 'Python':
    print('Верно! Мы ботаем Python =)')
    print('Python - отличный язык!')
  ```
  
**Программа** просит **пользователя** ввести текст и проверяет результат ввода. 

- Если введённый текст равен строке `Python`, то выводит **пользователю** текст:
  
  ```python
  Верно! Мы ботаем Python =)
  Python - отличный язык!
  ```

**Двоеточие (`:`)** в конце **строки с инструкцией `if`** сообщает интерпретатору **Python**, что дальше находится **блок команд**.

В **блок команд** входят **все строки с отступом под строкой с инструкцией `if`**, вплоть до следующей **строки без отступа**.

Если условие **истинно**, выполняется **весь расположенный ниже блок**.

В приведённом выше примере блок инструкций составляет третья и четвёртая строки программы.

**Блоком кода** называют объединённый друг с другом **строки**. Они **всегда** связаны с определённой частью программы(например с инструкцией  **`if`**)

Некоторым инструкциям в **Python** (например, инструкции **`if`**) именно **блок кода** сообщает, какие действия следует предпринять. После **`if`** блок кода информирует интерпретатор **Python**, как действовать, если условие **истинно**, и как — если оно **ложно**.

<img width="235" height="132" alt="image" src="https://github.com/user-attachments/assets/e05482ca-530c-43a4-9208-e5082c527d65" />

Предыдущая программа выводит текст в случае, если условие **истинно**. Но если условие **ложно**, то программа ничего не выводит.

- Для того, чтобы обеспечить возможность выполнять что-либо в случае, если условие оказалось **ложным**, необходимо использовать **ключевое слово `else`**:
  
  ```python
  answer = input('Какой язык программирования мы изучаем?')
  
  if answer == 'Python':
      print('Верно! Мы ботаем Python =)')
      print('Python - отличный язык!')
  else:
      print('Не совсем так!')
  ```

В новой программе обрабатываются сразу **два случая**: если условие **истинно**(пользователь ввёл **'Python'**) и если условие **ложно**(пользователь ввёл что угодно, кроме **'Python'**).

<img width="221" height="203" alt="image" src="https://github.com/user-attachments/assets/5552eee7-e075-4bf9-ba0d-f59ff40fbd42" />


#### Отступы


В некоторых языках программирования **отступы** - дело личного вкуса, и можно вообще обходиться без них. 

Однако в **Python** они - **неотъемлемая часть кода**. Именно **отступ** сообщает интерпретатору **Python**, где начинается и где заканчивается блок кода.

**Отступ** - небольшое смещение **строки кода** вправо. В начале такой **строки** находятся **пробелы**, и поэтому она на **несколько символов** отделена от **левого края**.


#### Операторы сравнения


Можно заметить, что в **проверке условия** использовалось **двойное равенство `==`** вместо ожидаемого **одиночного `=`**.

Не стоит путать **оператор присваивания `=`** с **условным оператором `==`**.

- **Оператор присваивания `=`** присваивает **переменным** значения:

  ```python
  num = 1992
  s = 'I love Python'
  ```

- Для проверки **двух элементов**  на равенство **Python** использует **удвоенный** знак равно **`==`**:

  ```python
  if answer == 'Python':
      ...
  
  if name == 'Gvido':
      ...
  
  if temperature == 40:
      ...
  ```

  
##### 6 основных операторов сравнения


- Оператор сравнения **больше `>`**:

  ```python
  if x > 7 # Если x больше 7
  ```
- Оператор сравнения **меньше `<`**:

  ```python
  if x < 7 # Если x меньше 7
  ```
- Оператор сравнения **больше либо равно `>=`**:
  
  ```python
  if x >= 7 # Если x больше либо равен 7
  ```
- Оператор сравнения **меньше либо равно `<=`**:

  ```python
  if x <= 7 # Если x меньше либо равен 7
  ```
- Оператор сравнения **равно `==`**:
  
  ```python
  if x == 7 # Если x равен 7
  ```
- Оператор сравнения **не равно `!=`**:

  ```python
  if x != 7 # Если x не равен 7
  ```

  
##### Цепочки сравнений


**Операторы сравнения** в **Python** можно объединят в **цепочки**(в отличие от большинства других языков программирования, где для этого нужно использовать **логические связки**).

Например, **`a == b == c`** или **`1 <= x <= 10`**.

- Следующий код проверяет, находится ли значение **переменной `age`** в диапазоне от 3 до 6:

  ```python
  age = int(input())
  if 3 <= age <= 6:
      print('Вы ребёнок')
  ```

  
##### Транзитивность


**Транзитивность** - это свойство отношения "переходить" или "передаваться" от одного **элемента** к друому: если **элемент a** связан с **b**, а **b** связан с **c**, то **a** также связан с **c**.

**Операция равенства - `==`** является **транзитивной**.

Это значит, что если **`a == b`** и **`b == c`**, то из этого следует, что **`a == c`**.

Именно поэтому код, проверяющий **равенство трёх переменных**, работает, как надо.

Другие примеры **транзитивных операций**:

- **Отношение порядка**: если a > b и b > c, то a > c;
- **Параллельность прямых**: если a || b и b || c, то a || c;
- **Делимость**: если a делится на b и b делится на c, то a делится на c.

Наглядный пример транзитивного отношения порядка: если друг слева старше вас(**a > b**), а вы старше друга справа(**b > c**) то друг слева точно старше друга справа(**a > c**).

**Операция неравенства `!=`** в отличие от **операции равенства `==`**, является **нетранзитивной**.

То есть из того, что **`a != b`** и **`b != c`** вовсе не следует, что **`a != c`**.

Действительно, если вас зовут не так, как одного из ваших друзей и не так, как ещё одного из ваших друзей, то нет никакой гарантии, что у этих друзей не окажутся одинаковые имена.


### Важные моменты:


По соглашению **PEP 8**, для **отступа блоков кода** используются **4 пробела**. 

Если в среде **VS Code** или **Wing IDE** нажать на клавишу **Enter** после **`if`**, она автоматически выставит **4 пробела**.

Путаница с операторами **`==`** и **`=`** является одной из **самых распространённых ошибок в программировании**.

Эти **символы** используются не только в **Python**, и каждый день **множество** программистов используют их **неправильно**.


###  Примеры кода:


1. Пример работы операторов сравнения:
   
  ```python
  num1 = int(input())
  num2 = int(input())
  
  if num1 < num2:
      print(num1, 'меньше чем', num2)
  if num1 > num2:
      print(num1, 'больше чем', num2)
  
  if num1 == num2:  # используем двойное равенство
      print(num1, 'равно', num2)
  if num1 != num2:
      print(num1, 'не равно', num2)
  ```

2. Пример кода, проверяющего равенство трёх переменных:
   
  ```python
  if a == b == c:
      print('числа равны')
  else:
      print('числа не равны')
  ```

3. Программа для подсчёта количества чётных чисел из 3 введённых:
   
  ```python
  num1, num2, num3 = int(input()), int(input()), int(input()) # Множественно считываем и присваиваем данные
  
  counter = 0  # переменная счётчик
  if num1 % 2 == 0:
      counter = counter + 1  # увеличиваем счётчик на 1
  if num2 % 2 == 0:
      counter = counter + 1  # увеличиваем счётчик на 1
  if num3 % 2 == 0:
      counter = counter + 1  # увеличиваем счётчик на 1
  
  print(counter)
  ```

4. Программа, которая определяет, состоит ли двузначное число введённое с клавиатуры из одинаковых цифр.
   
  ```python
  num = int(input())
  
  last_digit = num % 10    # последняя цифра числа
  first_digit = num // 10  # первая цифра числа
  
  if last_digit == first_digit:
      print('ДА')
  else:
      print('НЕТ')
  ```


## Конспект по теме: "Логические операторы, понятия truthy и falsy"


### Основные понятия:


В **Python** есть **три логических оператора**, которые позволяют создавать сложные условия:

- **`not`** - логическое отрицание;
- **`and`** - логическое умножение;
- **`or`** - логическое сложение.


#### Оператор `not`


**Оператор `not`** позволяет **инвертировать(т.е. заменить на противоположный)** результат **логического выражения**.

- Например следующий код:

  ```python
  age = int(input('Сколько вам лет?: '))
  if not (age < 12):
      print('Доступ разрешен.')
  else:
      print('Доступ запрещен.')
  ```
- Полностью эквивалентен коду:

  ```python
  age = int(input('Сколько вам лет?: '))
  if age >= 12:
      print('Доступ разрешен.')
  else:
      print('Доступ запрещен.')
  ```
В первом примере выражение **`age < 12`** было помещено в скобки для того, чтобы было чётко видно, что применяется **оператор `not`** к **значению выражения `age < 12`** а не только к **переменной `age`**.

**Операндом оператора `not`** может быть объект **любого типа**.

Если **операнд** отличен от значений **`True`** и **`False`**, он оценивается в соответствии с концепцией **`truthy`** и **`falsy`** объектов.

При этом результатом работы оператора **`not`** **всегда является** значение **`True`** или **`False`**.

- Приведённый ниже код:

  ```python
  print(not False)
  print(not None)
  print(not 0)
  print(not 0.0)
  print(not [])
  print(not '')
  print(not {})
  ```
  Выводит:
  
  ```python
  True
  True
  True
  True
  True
  True
  True
  ```

- Приведённый ниже код:
  
  ```python
  print(not True)
  print(not 123)
  print(not 69.96)
  print(not 'beegeek')
  print(not [4, 8, 15, 16, 23, 42])
  print(not {1, 2, 3})
  ```
  
  Выводит:
  
  ```python
  False
  False
  False
  False
  False
  False
  ```

  
##### Таблица истинности для оператора `not`


<img width="158" height="125" alt="image" src="https://github.com/user-attachments/assets/205a6877-a274-428a-b0a9-0dc5b3149a0e" />

Т.е. **оператор `not`** меняет значения на противоположные.


#### Оператор `and`


**Оператор `and`** означает, что в определённом **ветвлении** блок кода выполняется только при выполнении **обоих условий одновременно!**

- Например:
  
  ```python
  age = int(input('Сколько вам лет?: '))
  height = int(input('Каков ваш рост?: '))
  if age >= 18 and height >= 165:
      print('Доступ на водную горку разрешен.')
  else:
      print('Доступ на водную горку запрещен.')
  ```

Оператор **`and`** может объединят любое количество **условий**

Операндами оператора **`and`** могут быть **объекты любых типов данных**. По аналогии с оператором **`not`** можно предположить, что результатом работы оператора **`and`** также является значение **`True`** или **`False`**.

Однако на самом деле данный оператор возвращает **один из своих операндов**, а какой именно - зависит от самого **оператора**.

- Приведённый ниже код:

  ```python
  print(None and 10)
  print(5 and 0.0)
  print('aboba' and {})
  print([1, 2, 3] and [6, 9])
  
  print(1 and 'aboba' and None)
  print('habr' and 0 and {'one': 1})
  print(10 and [6, 9] and [])
  ```
  
  Выводит:
  
  ```python
  None
  0.0
  {}
  [6, 9]
  None
  0
  []
  ```

Из этого примера видно, что **оператор `and`** возвращает **первый `falsy` объект либо последний объект, если `falsy` объекты в логическом выражении не найдены**.


##### **Таблица истинности** для **оператора `and`**:


<img width="233" height="216" alt="image" src="https://github.com/user-attachments/assets/6c79a152-bd24-4f9a-8592-d5b9e0e963f6" />


Исходя из **таблицы истинности**, для выполнения кода, необходимо, чтобы одновременно выполнялись **абсолютно все условия**, связанные оператором **`and`**.


#### Оператор `or`


**Оператор `or`** также применяется для **объединения/связывания** условий.

В отличие от **`and`**, для выполнения **блока кода** достаточно выполнения **хотя бы одного из условий**.

Например:

  ```python
  town = input('В каком городе вы живёте?: ')
  if town == 'Екатеринбург' or town == 'Челябинск':
      print('Доступ открыт')
  else:
      print('Доступ закрыт')
  ```

Доступ будет разрешён если хотя-бы одно из условий выполнится.

Операндами **оператора `or`**, как в случае с **`not`** и **`and`**, могут быть объекты любых типов данных.

**Оператор `or`**, как и **оператор `and`** возвращает **один из своих операндов**. И какой именно, также зависит от самого **оператора**.

- Приведённый ниже код:

  ```python
  print(None or 0)
  print(0 or 5)
  print('aboba' or None)
  print([1, 2, 3] or [6, 9])
  
  print(1 or 'aboba' or None)
  print(0.0 or 'habr' or {'one': 1})
  print(0 or '' or [6, 9])
  print(0 or '' or [])
  print(0 or '' or [] or {})
  ```

  Выводит:

  ```python
  0
  5
  aboba
  [1, 2, 3]
  1
  habr
  [6, 9]
  []
  {}
  ```

Как видно из примера, **оператор `or`** оценивает каждый свой **операнд** как **`truthy`** или **`falsy`** объект, однако возвращает не значение **`True`** или **`False`**, а **сам объект** по определённому правилу - **первый `truthy` объект, либо последний объект, если `truthy` объекты в логическом выражении не найдены**.


##### **Таблица истинности для оператора `or`**:


<img width="229" height="212" alt="image" src="https://github.com/user-attachments/assets/c7b22df8-e3d8-4daf-8c62-8a6a02af00c6" />


Чтобы выражение **`or`** выполнялось, требуется, чтобы **хотя бы одно** условие **оператора `or`** выполнялось. 

При этом абсолютно не имеет значения, выполняется или нет второе или любое другое связанное условие.


#### Общий вывод по таблицам истинности логических операторов


Когда операндами **логических операторов** являются объекты **`True`** и **`False`**, работа **логических операторов** в **Python** также соответствует данным **таблицам истинности**.

- Приведённый ниже код:
  
  ```python
  print(not True)
  print(not False)
  print(False and True)
  print(True and True)
  print(False or True)
  print(False or False)
  ```
  Выводит:
  
  ```python
  False
  True
  False
  True
  True
  False
  ```
  
Однако **Python** не ограничивает нас только значениями **`True`** и **`False`** в качестве **операндов логических операторов**.

**Операндами операторов `not`, `and` и `or`** могут быть объекты **любых других типов данных**.


#### Понятия truthy и falsy объектов


Одной из важных особенностей языка **Python** является концепция **`truthy`** и **`falsy`** объектов.

Любой **объект** в **Python** может быть оценён как **`True`** или **`False`**. 

При этом **объекты**, которые оцениваются как **`True`**, называются **`truthy`** объектами.

А **объекты**, которые оцениваются как **`False`** - **`falsy`** объектами.


##### Что относится к встроенным `falsy` объектам


К встроенным **`falsy`** объектам относятся:

- значение **`False`**
- значение **`None`**
- нули числовых типов данных: **`0`**, **`0.0`**, **`0j`**, **`Decimal(0)`**, **`Fraction(0, 1)`**
- пустые последовательности и коллекции: **`''`**, **`()`**, **`[]`**, **`{}`**, **`set()`**, **`range(0)`**.

Другие **объекты встроенных типов данных** относятся к **`truthy` объектам**.

Экземпляры пользовательских классов по умолчанию также являются **`truthy`** объектами.


##### Встроенная функция `bool()`


Чтобы привести **объекты** к значению **`True`** или **`False`**, используется **встроенная функция `bool()`**.

- Приведённый ниже код:
  
  ```python
  # falsy объекты
  print(bool(False))
  print(bool(None))
  print(bool(0))
  print(bool(0.0))
  print(bool([]))
  print(bool(''))
  print(bool({}))
  
  #truthy объекты
  print(bool(True))
  print(bool(123))
  print(bool(69.96))
  print(bool('abobus'))
  print(bool([4, 8, 15, 16, 23, 42]))
  print(bool({1, 2, 3}))
  ```
  Выводит:
  
  ```python
  False
  False
  False
  False
  False
  False
  False
  True
  True
  True
  True
  True
  True
  ```


##### Работа `truthy` и `falsy` объектов с условным оператором


Концепция **`truthy`** и **`falsy`** объектов в **Python** позволяет работать с **условным  оператором** в более простой манере.

- Например, приведённый ниже код:
  
  ```python
  if len(data) > 0:
      ...
  
  if value == True:
      ...
  
  if value == False:
      ...  
  ```
  Можно переписать в виде:
  
  ```python
  if data:
      ...  
  
  if value:
      ...  
  
  if not value:
      ...
  ```

Т.е. можно не писать явных условий, пользуясь данной концепцией.


###### Примеры упрощённой записи условного оператора с различными объектами Python согласно концепции `truthy` и `falsy` объектов.


<img width="719" height="94" alt="image" src="https://github.com/user-attachments/assets/73f68668-8272-4ec6-b692-7c668543df0a" />


#### Приоритеты выполнения логических операторов


**Логические операторы**, подобно арифметическим операторам(`+`, `-`, `*`, `/`), имеют **приоритет выполнения**.

**Приоритет выполнения** следующий:

1. В **первую очередь** выполняется **логическое отрицание `not`**;
2. Во **вторую очередь** выполняется **логическое умножение `and`**;
3. И в **последнюю очередь** выполняется **логическое сложение `or`**.

- Согласно **приоритету логических операторов** приведённый ниже код:
  
  ```python
  a = 0
  b = 7
  c = 10
  print(not a and b or not c)        # 7
  ```

  Эквивалентен следующему:
  
  ```python
  a = 0
  b = 7
  c = 10
  print(((not a) and b) or (not c))  # 7
  ```

Но по отношению к другим **операторам Python**(за исключением **оператора присваивания `=`**) **логические операторы имеют самый низкий приоритет выполнения**.

Для **явного указания порядка** выполнения условных операторов **используют скобки**.

- Например, приведённый ниже код:
  
  ```python
  a = 5
  b = 7
  print(not a == b)  # True
  ```
  
  Эквивалентен следующему:
  
  ```python
  a = 5
  b = 7
  print(not (a == b))  # True
  ```

- Также стоит отметить, что запись вида:
  
  ```python
  a = 5
  b = 7
  print(a == not b)
  ```
  недопустима и приводит к возбуждению **исключения `SyntaxError`**.

Для наибольшей наглядности приведём ещё один пример.

- Приведённый ниже код:
  
  ```python
  print(not 1 == 2 or 3 == 3 and 5 == 6)  
  ```

  Выводит:
  
  ```python
  True
  ```

  Согласно **приоритету операторов** в **первую очередь** вычисляются выражения **`1 == 2`**, **`3 == 3`** и **`5 == 6`**, в результате чего **исходное выражение** принимает вид **`not False or True and False`**.
  
  Далее выполняется **оператор `not`**, возвращая значение **`True`**, после него - **оператор `and`**, возвращая значение **`False`**.
  
  **Выражение** принимает вид **`True or False`**. Последним выполняется **оператор `or`**, возвращая **общий результат выражения** - значение **`True`**.
  
#### Вложенный оператор

Внутри **условного оператора** можно использовать любые инструкции языка **Python**, в том числе и **условный оператор**.

При таком использовании получается **вложенное ветвление**: после одной развилки в ходе выполнения программы появляется другая. При этом **вложенные блоки имеют больший размер отступа**(+4 пробела для каждого следующего уровня)

- Вот как это должно выглядеть:
    
  ```python
  if условие1:
      блок кода
  else:
      if условие2:
          блок кода
      else:
          if условие3:
              блок кода            
        ...  
  ``` 

- Пример использования вложенного условного оператора:

  ```python
  grade = int(input('Введите вашу отметку по 100-балльной системе: '))
  
  if grade >= 90:
      print(5)
  else:
      if grade >= 80:
          print(4)
      else:
          if grade >= 70: 
              print(3)
          else:
              if grade >= 60:
                  print(2)
              else:
                  print(1)        
        ...  
    ``` 
  В этом примере уровень вложенности настолько глубок, что код становится трудным в понимании.

  Здесь имеет смысл избегать глубокого вложения. Для этого в **Python** есть **каскадный условный оператор**.

#### Каскадный условный оператор

Если требуется проверить **несколько** условий, в языке **Python** используется **каскадный условный оператор**.

- Синтаксис **каскадного условного оператора** имеет вид:
  
  ```python
  if условие1:
    блок кода
  elif условие2:
    блок кода
  ...
  else:
    блок кода
  ```

При исполнении такого **условного оператора** сначала проверяется **условие1**. Если оно истинно, то исполняется блок кода, который следует сразу после него вплоть до **выражения `elif`**. Остальная часть конструкции **игнорируется**. Однако, если **условие1** является ложным, то программа перескакивает непосредственно к следующему **выражению `elif`** и проверяет условие2. Если оно истинное, то исполняется блок кода, который следует сразу после него, вплоть до следующего **выражения `elif`**. И остальная часть условного оператора тогда **игнорируется**.

Этот процесс продолжается до тех пор, пока не будет найдено **условие**, которое является истинным, либо пока больше не останется **выражений `elif`**. Если ни одно условие не является истинным, то исполняется блок кода после **выражения `else`**.

- Пример каскадного условного оператора **`if-elif-else`**:
   
  ```python
  grade = int(input('Введите вашу отметку: '))
  
  if grade >= 90:
      print(5)
  elif grade >= 80:
      print(4)
  elif grade >= 70:
      print(3)
  elif grade >= 60:
      print(2)
  else:
      print(1)
  ```

Выравние и выделение отступом, которые применены в инструкции **`if-elif-else`**: выражения **`if`**, **`elif`** и **`else`** выравнены и исполняемые по условию блоки выделены одним отступом.


### Важные моменты:

#### Логические операторы ленивы

**Логические операторы** в **Python** являются **ленивыми**.

Это означает, что **возвращаемый операнд** вычисляется путём оценки **истинности** всех операндов **слева направо** до тех пор, пока это остаётся актуальным:

- Если **левый операнд** оператора **`or`** является **`truthy`** объектом, то общим результатом логического выражения является **`True`**, независимо от значения **правого операнда**.
- Если **левый операнд** оператора **`and`** является **`falsy`** объектом, то общим результатом логического выражения является **`False`**, независимо от значения **правого операнда**

Данный механизм называется **вычислением по короткой схеме(short-circuit evaluation)** и используется интерпретатором для оптимизации вычислений.

Наглядный пример:

- Приведённый ниже код :
  
  ```python
  def f():
      print('abo')
      return 3
    
  if True or f():
      print('bus')
  ```

  выводит:
  
  ```python
  bus
  ```

**Левым** операндом оператора **`or`** является **`truthy`** объект(значение **`True`**), значит, для вычисления **общего результата** логического выражения **нет необходимости вычислять правый операнд**, т.е. вызывать функцию **`f()`**. Поскольу вызова функции не происходит, в **выводе** отсутствует строка `abo`.

Общим результатом логического выражения является значение **`True`**, а значит, выполняются инструкции **блока кода** условного оператора, и в выводе видно строку `bus`.

- Напротив, приведённый ниже код:

  ```python
  def f():
      print('abo')
      return 3
    
  if True and f():
      print('bus')
  ```

  выводит:
  
  ```python
  abo
  bus
  ```
Т.к. **левым** операндом оператора **`and`**  является **`truthy`** объект, значит, для вычисления общего результата логического выражения **необходимо вычислить и правый операнд**, т.е. вызвать функцию `f()`. 

В результате вызова выполняются инструкции из **тела функции**, поэтому в выводе мы видим строку `abo`.

Функция возвращает число `3`, которое также является **`truthy`** объектом. Таким образом, общим результатом логического выражения является число `3`, а значит, выполняются инструкции **блока кода** условного оператора, и в выводе мы видим строку `bus`.

#### Укороченная схема вычисления `and` и `or`


**Оба оператора, `and` и `or`**, вычисляются по **укороченной схеме**.

Вот как это работает с **оператором `and`**:

- Если условие **слева** от **оператора `and`** является **ложным**, то условие **справа** от него **не проверяется**, так как **результат выражения будет гарантированно ложным** и проверка оставшегося условия — пустая трата процессорного времени.

- Например, в таком выражении:

  ```python
  5 > 100 and 10 > 0
  ```
  Вычисляется только выражение **`5 > 100`**. Оно **ложно**, а при **операторе `and`** оба выражения **должны быть правдивы**, чтобы **результат был `True`**.

  Но уже одно из выражений **не правдиво**, значит, результат и так будет **`False`**.

  Поэтому и **не требуется** вычислять **второе выражение**, т.к. оно **не повлияет на результат**.


**Аналогично работает оператор `or`**.


Если **условие слева** от **оператора `or`** - **истинное**, то **условие справа** от него **не проверяется**.

Действительно, результат будет **гарантированно истинным** и проверка оставшегося условия станет пустой тратой **процессорного времени**.

- Например, в таком выражении:
  
  ```python
  10 > 0 or 5 > 100
  ```
  вычисляется только **выражение `10 > 0`**. Оно **правдиво**, значит результат будет тоже **правдив**.

  Так как нам достаточно только **одного правдивого выражения** при **операторе `or`**.

#### Для вложенных и каскадных операторов

Инструкция **`if-elif-else`** не является обязательной, потому что её логика может быть запрограммирована вложенными инструкциями **`if-else`**. 

Однако длинная серия вложенных инструкций **`if-else`** имеет два характерных недостатка:

- программный код может стать сложным и трудным для восприятия;
- из-за необходимого выделения отступом продолжительная серия **вложенных инструкций `if-else`** может стать слишком длинной, чтобы целиком уместиться на экране монитора без горизонтальной прокрутки.

**Заключительный блок `else`** в операторе **`if-elif-else`** является **необязательным**.


### Примеры кода:


1. Одновременное использование **`and`** и **`or`**:

  ```python
  age = int(input('Сколько вам лет?: '))
  grade = int(input('В каком классе вы учитесь?: '))
  city = input('В каком городе вы живете?: ')
  if age >= 12 and grade >= 7 and (city == 'Москва' or city == 'Санкт-Петербург'):
      print('Доступ разрешен.')
  else:
      print('Доступ запрещен.')
  ```

## Конспект по теме "Цикл `for`"

### Основные понятия

Одно из преимуществ компьютеров над людьми - способность повторять одни и те же действия многократно, быстро и совсем не утомляясь.

В **Python** существует **две** основных разновидности циклов:
- циклы, повторяющиеся **определённое** количество раз(**`for`**, счетные циклы, **counting loops**);
- циклы, потворяющиеся до наступления **определённого события**(**`while`**, условные циклы, **conditional loops**).

**Цикл `for`** замечательно работает, если заранее известно количество повторений(итераций), которые требуется выполнить.

- Структура цикла **`for`** в **Python** выглядит так:

  ```python
  for название_переменной_цикла in range(количество_повторений):
      блок кода
  ```

**Двоеточие (`:`)** в конце строки с **инструкцией `for`** сообщает интерпретатору **Python**, что дальше находится **блок команд**. 

В блок команд входят все строки, расположенные с отступом от строки с **инструкцией `for`**, вплоть до следующей строки без отступа.
- **Блок команд**, который выполняется в цикле **`for`**, называется **телом цикла**.

До изучения цикла **`for`** я считывал несколько чисел при помощи нескольких команд **`input()`**.

А теперь, с помощью цикла **`for`** можно считывать и обрабатывать сколько душе угодно чисел.

- Например:

  ```python
  for i in range(5):
      num = int(input())
      print('Квадрат вашего числа равен:', num * num)
  
  print('Цикл завершен')

  ```
  Такая программа считывает 5 чисел и выводит на экран их квадраты вместе с поясняющей надписью.

  Поскольку **вторая** и **третья** строки выделены отступом, **Python** считает, что это **тело цикла**, которое выполняется **5 раз**.

  **Четвертая** строка не содержит отступа, поэтому **не является частью цикла и будет выполнена всего один раз**, после того, как цикл завершится.

#### Переменная цикла

- Ещё раз взглянув на базовую структуру цикла **`for`**:

  ```python
  for название_переменной_цикла in range(количество_повторений):
      блок кода
  ```
  Не совсем понятно, для чего нужна и как вообще работает **переменная цикла**.
- Рассмотрим следующий код:

  ```python
  for i in range(10):
      print(i)
  ```

  Результатом выполнения будет:

  ```python
  0
  1
  2
  3
  4
  5
  6
  7
  8
  9
  ```

  Когда цикл впервые начинает работу, **Python** устанавливает значение **переменной цикла `i = 0`**.

  Каждый раз, когда повторяется **тело цикла**, **Python** увеличивает **значение переменной на 1**.

Поскольку **переменная цикла `i`** увеличивается на 1 каждый раз, то её можно использовать для отслеживания **номера итерации** на которой мы находимся в **циклическом процессе**.

- Рассмотрим следующий код:

  ```python
  for i in range(10):
      print(i, '-- Привет')
  ```
 
  Результатом выполнения будет:

  ```python
  0 -- Привет
  1 -- Привет
  2 -- Привет
  3 -- Привет
  4 -- Привет
  5 -- Привет
  6 -- Привет
  7 -- Привет
  8 -- Привет
  9 -- Привет
  ```
  
  Если хотим начать с 1, то можно написать код:

  ```python
  for i in range(10):
      print(i + 1, '-- Привет')
  ```
  
  Результатом выполнения будет:

  ```python
  1 -- Привет
  2 -- Привет
  3 -- Привет
  4 -- Привет
  5 -- Привет
  6 -- Привет
  7 -- Привет
  8 -- Привет
  9 -- Привет
  10 -- Привет
  ```

  Именно за счёт выражения **`i + 1`**, мы начинаем вывод с 1, а не с 0.

#### Имена переменных цикла

Ранее говорилось, что **имена переменных** должны носить осмысленный характер и описывать их назначение. Однако для переменных цикла иногда делаются исключения. 

В программировании для **переменных цикла** обычно используют буквы **`i`, `j`, `k`**.

Почекму для переменной циклов зарезервированы именно эти три буквы?

Дело в том, что раньше программы использовали для математических расчётов, а в **математике** буквы **`a`, `b`, `c`, `x`, `y`, `z`** уже зарезервированы для других целей.

Поэтому программисты выбрали для этой цели **переменые `i`, `j`, `k`**, и это стало общепринятой практикой.

Бывают ситуации, когда переменная цикла не используется в его теле. 

- В таком случае, вместо того, чтобы давать ей имя, можно указать **символ нижнего подчёркивания `_`**:

  ```python
  for _ in range(5):
      print('Python - awesome!')
  ```
  
  Результатом выполнения будет:

  ```python
  Python - awesome!
  Python - awesome!
  Python - awesome!
  Python - awesome!
  Python - awesome!
  ```

Если **переменная цикла не используется в теле цикла, то указываем вместо неё символ нижнего подчёркивания `_`**.
  

#### Функция `range()`

**Функция `range(stop)` генерирует последовательность чисел** от **`0`** до **`stop - 1`**, а цикл **`for`** последовательно перебирает эту последовательность.

Функция **`range()`** может принимать от **одного** до **трёх** параметров:
**`range(stop), range(start, stop), range(start, stop, step)`**:
- параметр **`start`** - это старт последовательности(включительно)
- параметр **`stop`** - это стоп последовательности(не включительно)
- параметр **`step`** - это величина шага

Величина **шага** не может равняться **0**. 

- Приведённый ниже код:

  ```python
  for i in range(1, 10, 0):
      print(i)
  ```
  
  приводит к возникновению ошибки:
  
  ```python
  ValueError: range() arg 3 must not be zero
  ```
  
  
  
##### Функция `range()` с одним параметром

- Рассмотрим такой код:

  ```python
  for i in range(10):
      print('Привет', i)
  ```
  
Значение, которое указывается в скобках у функции **`range()`** обозначает количество итераций цикла, при этом переменная **`i`** принимает последовательно значения: **`0, 1, 2, 3, 4, 5, 6, 7, 8, 9`**.

##### Функция `range()` с двумя параметрами

Если необходимо начать последовательность не с **`0`**, а с другого числа, то можно  использовать **перегрузку функции `range()`**, принимающую **два параметра**.

Например, вызов функции **`range(1, 5)`** сгенерирует последовательность чисел от **1** до **4**, т.к. правая граница **невключительна**. 

Таким образом:
- **`range(stop)`**: создает последовательность чисел **0, 1, 2, 3, ..., stop - 1**;
- **`range(start, stop)`**: создает последовательность чисел **start, start + 1, start + 2, ..., stop - 2, stop - 1**.

Если **первый параметр больше второго**, то функция **`range()`** сгенерирует **пустую последовательность**. 

Например, вызов функции **`range(10, 1)`** приводит к генерации **пустой последовательности**.

Передавая **два параметра** в функцию **`range()`** можно генерировать любую последовательность целых чисел с шагом **1**.

##### Функция `range()` с тремя параметрами

Выглядит она так: **`range(start, stop, step)`**:
- первый  параметр задает **старт последовательности**;
- второй параметр задаёт **стоп последовательности**;
- третий параметр задаёт **шаг генерации** чисел.

Например, вызов функции **`range(1, 10, 2)`** создаст последовательность чисел **1, 3, 5, 7, 9**, а вызов функции **`range(5, 30, 5)`** сгенерирует последовательность **5, 10, 15, 20, 25**.

###### Отрицательный шаг генерации

Если **шаг генерации** является положительным числом, то генерируемая последовательность будет **возрастать**.

Если **шаг генерации*** является отрицательным числом, то генерируемая последовательность будет **убывать**.

В случае **отрицательного шага**, нужно гарантировать, что **старт последовательности**(первый параметр)
**больше**, чем **конец последовательности**(второй параметр).

Например, вызов функции **`range(20, 16, -1)`** создаст **последовательность чисел** **20, 19, 18, 17**, а вызов функции **`range(20, 10, -3)`** сгенерирует **последовательность** **20, 17, 14, 11**.

Если **величина шага отрицательна и первый параметр меньше второго**, то функия **`range()`** генерирует **пустую последовательность**. 

Например, вызов функции **`range(1, 10, -1)`** приводит к генерации **пустой последовательности**.


### Важные моменты 

Однократное выполнение тела цикла называется **итерацией цикла**.

**Правая граница** в цикле **Python** всегда **невключительна**.

- Приведённый ниже код:

  ```python
  for i in range(5):
      print(i)
  ```
  
  выводит :

  ```python
  0
  1
  2
  3
  4
  ```

  Если требуется включить правую границу, то можно использовать следующий код:

  ```python
  for i in range(5):
      print(i + 1)
  ```
  
  

### Примеры кода

1. Программа, которая выводит те числа из промежутка **[100; 999]**, которые кончаются на **7**:

  ```python
  for i in range(100, 1000):  # перебираем числа от 100 до 999
      if i % 10 == 7:         # используем остаток от деления на 10, для получения последней цифры
          print(i)
  ```

2. Программа, которая выводит **все четные числа** из промежутка **[56; 170]**, используя функцию **`range()`** с тремя параметрами:

  ```python
  for i in range(56, 171, 2):
      print(i)
  ```


## Конспект по теме: "Частые сценарии при написании циклов"

### Подсчёт количества

Довольно часто требуется, чтобы программа подсчитывала, сколько раз что-либо произошло.

Например, видеоигра, подсчитывающая количество поворотов персонажа, или математическая программа, считающая, как много чисел обладают некоторым свойством.

Ключ к **подсчёту** - использование **переменной счётчика**!

Для **переменной счётчика** удобно использовать имя **`counter`**.

**Подсчёт количества** - очень частый сценарий. 

Он состоит из двух шагов:
1. Создание **переменной счётчика** и придание ей первоначального значения: **`counter = 0`**;
2. Увеличение **переменной счётчика** на **`1`**: **`counter = counter + 1`**

Напишу программу, которая считывает **`10`** чисел и определяет, сколько из них **больше** **`10`**.

- Программа будет выглядеть так:

  ```python
  # создаём переменную счётчика
  counter = 0                                             
  for _ in range(10):
      num = int(input())
  # при выполнении условия
      if num > 10:
  # увеличиваем значение cчётчика                                         
          counter = counter + 1                           
  
  print('Было введено', counter, 'чисел, больших 10.')
  ```

Каждый раз, когда мы считываем число, большее **`10`**, мы добавляем **`1`** к текущему значению переменной **`counter`**. 

В программе это реализовано в строке **`counter = counter + 1`**.

Очень важно обратить внимание на то, что **начальное значение переменной счётчика - `counter = 0`**. 
Без **начального значения** мы получили бы **ошибку**, поскольку, дойдя до строки **`counter = counter + 1`**, **Python** ничего не знал бы о переменной **`counter`**.

Строка кода **`counter = counter + 1`** означает следующее: возьми **старое значение** переменной **`counter`**, прибавь к нему **`1`** и **переприсвой переменной это значение**.

Если не придать переменной **начальное значение**, то непонятно, к чему прибавлять **`1`** в самый первый раз.

Рассмотрим ещё один пример: подсчитать количество чисел из диапазона от **`1`** до **`100`**(включительно), квадрат которых оканчивается на **`4`**.

- Программа будет выглядеть так:

  ```python
  counter = 0
  for i in range(1, 101):
      if i**2 % 10 == 4:
          counter = counter + 1
  
  print(counter)
  ```

Здесь используется **функция `range()`** с **двумя** параметрами для генерации последовательности чисел от **`1`** до **`100`**. Каждый раз, когда переменная **`i`** последовательно принимает значения от **`1`** до **`100`**, мы проверяем условие: **`i**2 % 10 == 4`**(оканчивается ли квадрат числа **`i`** на **`4`**).

#### Использование нескольких счётчиков

Часто при написании программ требуется использовать несколько **счётчиков**.

Для примера модифицируем предыдущую программу: посчитаем ещё и количество **нулей** среди введённых чисел.

- Программа будет выглядеть так:

  ```python
  counter1 = 0
  counter2 = 0
  for _ in range(10):
      num = int(input())
      if num > 10:
          counter1 = counter1 + 1
      if num == 0:
          counter2 = counter2 + 1
  
  print('Было введено', counter1, 'чисел, больших 10.')
  print('Было введено', counter2, 'нулей.' )
  ```

### Вычисление суммы и произведения

#### Вычисление суммы

Наравне с **подсчётом количества** по частоте стоит задача **вычисления суммы**. К примеру, видеоигра должна считать **сумму очков***. В таком случае **начальное значение** переменной будет равно **`0`**, а далее оно будет увеличиваться на некоторое количество заработанных очков, например, на **`10`**.

- Пишется для этого следующий код:

  ```python
  score = 0
  ...
  score += 10
  ```

**Подсчёт суммы** состоит из **двух** шагов:
1. Создание переменной **сумматора** и придание ей **первоначального значения**: **`total = 0`**;
2. Увеличение переменной **сумматора** на **нужное число: `total += num`**.

Напишем программу, которая считывает **`10` чисел** и определяет **сумму** тех из них, которые **больше `10`**.

- Программа будет выглядеть так:

  ```python
  total = 0
  for _ in range(10):
      num = int(input())
      if num > 10:
          total += num
  
  print('Сумма чисел больших 10 равна',  total)
  ```

Каждый раз, когда программа **считывает число, большее `10`**, она добавляет его к текущему значению переменной **`total`**. Это реализовано в строке **`total += 1`**. Обращаем внимание на **начально значение переменной-сумматора `total = 0`**. 

Без начального значения мы бы получили ошибку, поскольку, дойдя до строки **`total += num`**, **Python** ничего не знал бы о переменной **`total`**.

Строка кода **`total += num`** означает: возьми старое значение переменной **`total`**, **прибавь** к нему **`num`** и **переприсвой переменной это значение**.

Если не придать переменной **начальное значение**, то не к чему прибавлять **`num`** в самый первый раз.

- Напишем программу, которая считает **сумму** натуральных чисел от **`1`** до **`100`**:

  ```python
  total = 0
  for i in range(1, 101):
      total = total + i
  
  print('Сумма равна', total)
  ```

- Рассмотрим ещё один пример: напишем программу, которая запрашивает **`10`** целых чисел и находит их **среднее значение**:

  ```python
  total = 0
  for _ in range(10):
      num = int(input())
      total = total + num
  
  average = total / 10
  print('Среднее значение равно', average)
  ```

#### Вычисление произведения

Произведение вычисляется аналогичным образом.

При вычислении произведения **начальное значение** переменной **мультипликатора** мы устанавливаем равным **`1`**, в отличие от **сумматора**, где оно равно **`0`**.

Для переменной **сумматора** и **мультипликатора** удобно использовать имя **`total`**.

### Максимум и минимум

Поиск **наибольшего** или **наименьшего** значения в некоторой последовательности чисел - также частая задача в **программировании**.

Для **переменных**, хранящих **наибольшее** и **наименьшее** значения, подходят имена **`largest`** и **`smallest`** соответственно. Лучше не называть такие переменные **`max`** или **`min`**, так как в **Python** есть встроенные функции **`max()`** и **`min`** и может возникать путаница.

#### Максимум

- Напишем программу, которая считывает **`10`** **положительных чисел** и находит среди них **наибольшее число**:

  ```python
  largest = 0
  for _ in range(10):
      num = int(input())    
      if num > largest:
          largest = num
  
  print('Наибольшее число равно', largest) 
  ```

Мы устанавливаем начальное значение переменной **`largest`** в **`0`**.

Далее программа считывает **`10`** чисел, и если какое-то из них оказывается **больше** текущего значения **`largest`**, **переприсваивает его**.

В качестве **начального значения** взято число **`0`**, поскольку мы знаем, что все числа **положительны**(а **`0`** является **максимальным неположительным числом**). 

Таким образом, уже первое сравнение приведёт к переприсваиванию.

Распространён подход, когда в качестве **начального значения** переменной сразу принимается **первый** элемент последовательности.

- Напишем программу, которая считывает **`10`** чисел(необязательно положительных) и находит среди них **наибольшее**:

  ```python
  largest = int(input())  # принимаем первое число за максимальное
  for _ in range(9):
      num = int(input())
      if num > largest:
          largest = num
  
  print('Наибольшее число равно', largest) 
  ```

#### Минимум

Для нахождения **наименьшего значения** последовательности следует поменять знак неравенства **`>`** на **противоположный `<`**. В таком случчае название переменной **`largest`** стоит заменить на **`smallest`**.









