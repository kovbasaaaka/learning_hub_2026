<img width="54" height="30" alt="image" src="https://github.com/user-attachments/assets/6eff1f34-97fb-4887-96f5-abefe3398477" /><img width="54" height="30" alt="image" src="https://github.com/user-attachments/assets/0705248e-631d-4fa5-bf3d-b5ea8f6e8807" />## Конспект по теме "Ревью кода"

### Основные понятия

#### Ревью кода

**Ревью кода** - это проверка исходного кода программы с целью обнаружения и исправления ошибок и неточностей, которые остались незамеченными при начальной разработке.

В процессе ревью кода могут быть исправлены:
- фактические ошибки;
- производительность кода;
- читабельность и ошибки форматирования кода.

Целью ревью кода является **улучшение качества программного кода и совершенствование навыков программиста**.

Как правило, ревью кода выполняет программист с большим опытом.

<img width="501" height="574" alt="image" src="https://github.com/user-attachments/assets/df31308d-f97b-4865-a792-69e70f60b3fd" />

##### Фактические ошибки

К **фактическим ошибкам** в коде относятся ошибки, из-за которых код может работать **неверно**. По сути, это ошибки, относящиеся к алгоритму, который используется в программе для решения задачи.

Среди частых фактических ошибок встречаются:
- отсутствие **начальной инициализации переменной**;
- неправильная **начальная инициализация переменной**;
- отсутвие **отступа** между блоками кода;
- неправильные числовые граничные значения, например при использовании функции **`range()`**;
- неправильные граничные сравнения(путаница с **`>, >=`** или **`<, <=`**);
- путаница логических операций **`or`** и **`and`** и так далее.

##### Производительность кода

Под производительностью кода в простейшем случае можно подразумевать то, **сколько времени программа тратит на решение задачи**. При написании программы, программист должен думать над тем, сколько времени в **худшем случае** потребуется его программе для решения задачи.

Рассмотрим задачу, которая проверяет число на простоту.

**Простое число** - это число, которое делится только на **`1`** и на **себя**.

**Составное число** - это **натуральное число**, которое больше единицы и имеет более двух делителей.

- 1 версия:

  ```python
  num = int(input())
  flag = True
  
  for i in range(2, num):
      if num % i == 0:
          flag = False
  
  if num == 1:
      print('Число равно 1')
  elif flag == True:
      print('Число простое')
  else:
      print('Число составное')
  ```
  Перебираем все числа от **`2`** до **`num - 1`**(включительно) и делаем проверку делимости числа **`num`** на **`i`**.

  Если программе на вход подаётся простое число **`num = 1934234249`**, то она будет выполняться примерно 270 секунд = 4.5 минуты!!!

- 2 версия:

  ```python
  num = int(input())
  flag = True
  
  for i in range(2, num // 2 + 1):
      if num % i == 0:
          flag = False
  
  if num == 1:
      print('Число равно 1')
  elif flag == True:
      print('Число простое')
  else:
      print('Число составное')
  ```

  Несложно понять, что перебирать все числа от **`2`** до **`num - 1`**(включительно) не имеет смысла. Достаточно проверить числа от **`2`** до **`num // 2`**(включительно).

  Теперь с теми же входными данными программа будет работать примерно 130 секунд = 2.2 минуты. Т.е. время работы улучшилось **ВДВОЕ**!!

- 3 версия:

  ```python
  num = int(input())
  flag = True
  
  for i in range(2, int(num ** 0.5) + 1):
      if num % i == 0:
          flag = False
  
  if num == 1:
      print('Число равно 1')
  elif flag == True:
      print('Число простое')
  else:
      print('Число составное')
  ```
  
  Правую границу **`num // 2`** проверки можно улучшить, если заметить, что у любого составного числа есть делитель(отличный от 1), не превосходящий **квадратного корня из числа**. Таким образом, имеет смысл перебирать делители от **`2`** до **`num ** 0.5`**(включительно).

  Теперь, если программе на вход подаётся то же самое простое число, то она будет работать примерно 0.066 секунд. **По сути мы улучшили время работы программы в 4000 раз!!!**.

- 4 версия:

  ```python
  num = int(input())
  flag = True
  
  for i in range(2, int(num ** 0.5) + 1):
      if num % i == 0:
          flag = False
          break
  
  if num == 1:
      print('Число равно 1')
  elif flag == True:
      print('Число простое')
  else:
      print('Число составное')
  ```
  Предыдущие оптимизации касались случая, когда проверяемое число является простым. В случае, если число является составным и мы нашли его первый делитель(отличный от 1), мы прерываем цикл с помощью оператора **`break`**.

  Число 1 не является ни простым, ни составным, т.к. у него только **один** делитель - оно само.

##### Читабельность кода

Следует помнить, что код должен легко читаться и быть понятным другим разработчикам.

Чтобы этого достичь, следует придерживаться стандарта **PEP 8**. 

Следует обращать внимание на следующие моменты:

1. **отступы и пробелы**: используйте 4 пробела на один уровень отступа и **никогда не смешивайте символы табуляции и пробелы**;
2. **названия переменных**: используйте говорящие названия для переменных(**`total`**, **`counter`**, **`product`**) и следуйте стилю **lower_case_with_underscores**(слова из маленьких букв с подчёркиваниями);
3. **пустые строки**: дополнительный отступы пустыми строками могут быть изредка полезны для **выделения группы логически связанных частей программы**:
   - **инициализация переменных**
   - **основной алгоритм**
   - **завершающая проверка**
   - и так далее;
4. **комментарии**: комментарии должны являться **законченными предложениями**. Если меняете код - обязательно меняйте и комментарии, иначе будет очень большая путаница.
   
  
- 
